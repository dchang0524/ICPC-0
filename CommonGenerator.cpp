//https://codeforces.com/contest/2029/problem/E
#include <bits/stdc++.h>


using namespace std;
typedef long long ll;


int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    //Consider a graph where you have nodes from 2, 3, ..., max_A
        //Create a directed edge from a to b if a + d = b where d | b and d >= 2
    //Notice 2 is a generator of all composite numbers x
        //if x is even, x-2, x-4, ..., 2, so 2 generates x
        //if x is odd, x = a*b where a,b > 1 and a,b odd
            // (a-1)*b + b = x, so (a-1)*b is a generator of x, and (a-1)*b is even
        //any smaller even number could generate a bigger even number
    //A prime can only be generated by itself
        //If the array has a prime, that prime must be the generator
        //2*p is the smallet number generated by p
    //The second biggest generator of an odd composite number x is x-d, where d is the smallest divisor of x
        //note x-d is even
    //The second biggest generator of an even composite number x is x-2
        //note x-2 is also even
    //If an array contains no primes besides 2, 2 is the smallest generator
    //If an array contains 2 or more primes, there is no generator
    //If an array contains 1 prime, p != 2:
        //p is the common generator, if one exists
        //2*p <= min(second smallest generator of (a_i)), where a_i != p and a_i % 2 == 1
        //2*p <= min(smallest generator of (a_i)), where a_i != p and a_i % 2 == 0
    int max_a = 400000;
    vector<int> sieve(max_a+1, 1);
    //could replace with a linear comlexity sieve
    for (int i = 2; i < max_a + 1; i++) {
        if (sieve[i] == 1) {
            sieve[i] = i;
            for (int j = i; j <= max_a; j+= i) {
                if (sieve[j] == 1)
                    sieve[j] = i;
            }
        }
    }

    // bool correctSieve = true;
    // for (int i = 1; i < max_a + 1; i++) {
    //     for (int j = 2; j < max_a + 1; j++) {
    //         if (j < i && sieve[i] > j && i % j == 0) {
    //             correctSieve = false;
    //             break;
    //         }
    //     }
    //     if (!correctSieve) {
    //         break;
    //     }
    //     cout << "finsihed i: " << i << endl;
    // }
    // cout << correctSieve << endl;

    // for (int i  = 0; i < max_a + 1; i++) {
    //     cout << "i: " << i << " sieve[i]: " << sieve[i] << endl;  
    // }

    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<int> a(N);
        for (int i = 0; i < N; i++) {
            cin >> a[i];
        }
        int prime = -1;
        int minGenerator = max_a;
        if (N == 1) {
            cout << a[0] << endl;
            continue;
        }

        bool works = true;
        //note all a_i are distinct
        for (int i = 0; i < N; i++) {
            if (sieve[a[i]] == a[i]) {
                if (prime != -1) {
                    works = false;
                    break;
                }
                prime = a[i];
            }
            else {
                if (a[i] % 2 == 1)
                    minGenerator = min(minGenerator, a[i] - sieve[a[i]]);
                else
                    minGenerator = min(minGenerator, a[i]);
            }
        }
        if (works) {
            if (minGenerator >= 2*prime) {
                if (prime == -1) {
                    prime = 2;
                }
                cout << prime << endl;
            }
            else {
                cout << "-1" << endl;
            }
        }
        else {
            cout << "-1\n";
        }

    }
}
